"""
Сортировка слиянием
Слияние отсортирванных масивов в один
"""
def merge(A:list,B:list):
    """
    Слияние отсортированных массивов в один С
    :param A: первый массив
    :param B: второй массив
    :return:
    """
    C = [0]*(len(A) + len(B))
    i = k = n = 0
    while i < len(A) and k < len(B):
        if A[i] <= B[k]:
            C[n] = A[i]
            i += 1
            n += 1
        else:
            C[n] = B[k]
            k += 1
            n += 1
    while i < len(A):
        C[n] = A[i]
        i += 1
        n += 1
    while k < len(B):
        C[n] = B[i]
        k += 1
        n += 1
    return C
"""
сортировка называется устойчивой, если она не меняет порядок равных элементов
"""
"""
рекурентная функция для сортировки
"""
def merge_sort(A):
    """
    рекурентная функция для сортировки принимает массива А
    :param A: массив
    :return:
    """
    if len(A) <= 1: # крайний случай
        return
    middle = len(A)//2 # делим массив А пополам,чтобы было два куска массива для сортировки этих кусков
    # срезам воспользуемся позже
    L = [A[i] for i in range(0, middle)] # левая половинка массива
    R = [A[i] for i in range(middle, len(A))]
    merge_sort(L)
    merge_sort(R)
    C = merge(L,R) #сливаем эти массивы пользуясь функцией выше
    for i in range(len(A)):#копируем по элементно в А элементы С.здесь прекрасно работали бы срезы,но это потом
        A[i] = C[i]

"""
Сортировка Тони Хоара (QuichSort)
"""
def hoar_sort(A):
    """
    Сортировка Тони Хоара
    :param A: массив А
    :return:
    """
    if len(A) <= 1: # берьерный элемент его надо писать в первую очкредь для рекурентныйх функций
        return
    L = [] # левая часть массива
    M = [] # центральная часть массива
    R = [] # правая часть массива
    barrier = A[0] # барьерный элемент для сортировки Тони Хоара, от него и видём сортировку,направо,лево и центр
    for x in A:
        if x < barrier:
            L.append(x)
        elif x == barrier:
            M.append(x)
        else:           # else не потребляет никаких условий
            R.append(x)
    hoar_sort(L)
    hoar_sort(R)
    k = 0 # счётчик который будет бежать по массиву А и класть L R в массив А
    for x in L + M + R:
        A[k] = x
        k+=1

"""
проверяем массив отсортирован или не отсортирован
"""
def check_sorted(A, ascending=True):
    """
    Функция проверки отсортирован ли массиов за время О(len(A))
    :param A:Сам массив
    :param ascending:  проверяем массив отсортирован ли по возрастанию True по убыанию False
    :return:
    """
    flag = True # флаг сортировки
    s = 2 * int(ascending) - 1 # небольшая математическая функция где ascending это либо True либо False и по алгебре логики мы получаем либо +1 либо -1
    for i in range(0, A-1):# потому что сравниваем пары элементов сравнение для N элементов будет A-1
        if s * A[i] > s * A[i + 1]:
            flag = False
            break
    return flag


